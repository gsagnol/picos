

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Cut problems in graphs &mdash; picos 1.0.1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="top" title="picos 1.0.1 documentation" href="index.html"/>
        <link rel="up" title="Examples" href="examples.html"/>
        <link rel="next" title="Complex Semidefinite Programming" href="complex.html"/>
        <link rel="prev" title="Examples from Optimal Experimental Design" href="optdes.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>



  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33037163-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  </script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        
              
              <a href="index.html" class="fa fa-home"> Home <img src="_static/picos_big_trans.gif" height="50px" width="200px"/> </a>
              
        
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="intro.html#first-example">First Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html#solvers">Solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html#requirements">Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html#installation">Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html#license">License</a></li>
<li class="toctree-l2"><a class="reference internal" href="intro.html#author-and-contributors">Author and contributors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tuto.html">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="tuto.html#variables">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuto.html#affine-expressions">Affine Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuto.html#norm-of-an-affine-expression">Norm of an affine Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuto.html#quadratic-expressions">Quadratic Expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuto.html#constraints">Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuto.html#write-a-problem-to-a-file">Write a Problem to a file</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuto.html#solve-a-problem">Solve a Problem</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="examples.html">Examples</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="optdes.html">Examples from Optimal Experimental Design</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Cut problems in graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="complex.html">Complex Semidefinite Programming</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">The PICOS Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="problem.html">Problem</a></li>
<li class="toctree-l2"><a class="reference internal" href="tools.html">picos.tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="expression.html">Expression</a></li>
<li class="toctree-l2"><a class="reference internal" href="constraint.html">Constraint</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="download.html">Download</a></li>
<li class="toctree-l1"><a class="reference internal" href="changes.html">Change History</a></li>
</ul>

        

      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">picos</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="examples.html">Examples</a> &raquo;</li>
      
    <li>Cut problems in graphs</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/graphs.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="cut-problems-in-graphs">
<span id="graphs"></span><h1>Cut problems in graphs<a class="headerlink" href="#cut-problems-in-graphs" title="Permalink to this headline">¶</a></h1>
<p>The code below initializes the graph used in all the examples of this page.
It should be run prior to any of the codes presented in this page.
The packages <a class="reference external" href="http://networkx.lanl.gov/index.html">networkx</a>
and <a class="reference external" href="http://matplotlib.sourceforge.net">matplotlib</a>
are recquired.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since Picos 1.0.1, it is possible to define flows on a graph
(i.e., a <a class="reference external" href="http://networkx.lanl.gov/index.html">networkx</a> object)
with the function
<a class="reference internal" href="tools.html#picos.tools.flow_Constraint" title="picos.tools.flow_Constraint"><code class="xref py py-func docutils literal"><span class="pre">flow_Constraint()</span></code></a>. It creates an object of the class
<code class="xref py py-class docutils literal"><span class="pre">_Flow_Constraint</span></code> that can be passed to a problem
with <a class="reference internal" href="problem.html#picos.Problem.add_constraint" title="picos.Problem.add_constraint"><code class="xref py py-func docutils literal"><span class="pre">add_constraint()</span></code></a>.
This automatically inserts a constraint for the flow conservation at each node
and the capacity  constraints for each edge. We have included an example
using the function <a class="reference internal" href="tools.html#picos.tools.flow_Constraint" title="picos.tools.flow_Constraint"><code class="xref py py-func docutils literal"><span class="pre">flow_Constraint()</span></code></a>
for the max-flow problem below, see <a class="reference internal" href="#newversion"><em>here</em></a>.</p>
</div>
<p>We use an arbitrary graph generated by the LCF generator of the networkx package.
The graph is deterministic, so that we can run doctest and check
the output. In this example, we also use a kind of arbitrary sequence for the edge capacities.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picos</span> <span class="kn">as</span> <span class="nn">pic</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>

<span class="c">#number of nodes</span>
<span class="n">N</span><span class="o">=</span><span class="mi">20</span>

<span class="c">#Generate a graph with LCF notation (you can change the values below to obtain another graph!)</span>
<span class="n">G</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">LCF_graph</span><span class="p">(</span><span class="n">N</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">14</span><span class="p">],</span><span class="mi">5</span><span class="p">)</span>
<span class="n">G</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="c">#edges are bidirected</span>

<span class="c">#generate edge capacities</span>
<span class="n">i</span><span class="o">=</span><span class="mi">0</span>
<span class="n">c</span><span class="o">=</span><span class="p">{}</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="mi">17</span>
        <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s">&#39;capacity&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">c</span><span class="p">[(</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">i</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
<div class="section" id="max-flow-min-cut-lp">
<h2>Max-flow, Min-cut (LP)<a class="headerlink" href="#max-flow-min-cut-lp" title="Permalink to this headline">¶</a></h2>
<div class="section" id="max-flow">
<h3>Max-flow<a class="headerlink" href="#max-flow" title="Permalink to this headline">¶</a></h3>
<p>Given a directed graph <img class="math" src="_images/math/225201b9f4e7b5d520f232cd2d2b27f402301764.png" alt="G(V,E)"/>,
with a capacity <img class="math" src="_images/math/6bbf77e6a4c4ee5647d9bb12100f0555505c1954.png" alt="c(e)"/> on each edge <img class="math" src="_images/math/9ff045e434b25b68e0fea4e8edf37606ca9d8a9b.png" alt="e \in E"/>,
a source node <img class="math" src="_images/math/6859317dd1b439cef34131bcd4bafee8393444e0.png" alt="s"/> and a sink node <img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/>, the <strong>max-flow</strong> problem is
to find a flow from <img class="math" src="_images/math/6859317dd1b439cef34131bcd4bafee8393444e0.png" alt="s"/> to <img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/> of maximum value. Recall that a flow
<img class="math" src="_images/math/6859317dd1b439cef34131bcd4bafee8393444e0.png" alt="s"/> to <img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/> is a mapping from <img class="math" src="_images/math/cfd13a0f26eb7ef0093319a7669da7dd3771dbac.png" alt="E"/> to <img class="math" src="_images/math/63a60afa4cea01779694c86b235bf404c3814a0e.png" alt="\mathbb{R}^+"/>
such that:</p>
<blockquote>
<div><ul class="simple">
<li>the capacity of each edge is respected: <img class="math" src="_images/math/6dc1bd5dd1a449410c939347cbfeba9d079a485b.png" alt="\forall e \in E,\ f(e) \leq c(e)"/></li>
<li>the flow is conserved at each non-terminal node:
<img class="math" src="_images/math/d5c24b9ae82ddde83092497c3c852945a3df0114.png" alt="\forall n \in V \setminus \{s,t\},\ \sum_{(i,n)\in E} f((i,n)) = \sum_{(n,j)\in E} f((n,j))"/></li>
</ul>
</div></blockquote>
<p>Its value is defined as the volume passing from <img class="math" src="_images/math/6859317dd1b439cef34131bcd4bafee8393444e0.png" alt="s"/> to <img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/>:</p>
<div class="math">
<p><img src="_images/math/8b3fa43e388cf37f2c6338689a67db1525ddbb11.png" alt="\mathrm{value} (f) = \sum_{(s,j)\in E} f((s,j)) - \sum_{(i,s)\in E} f((i,s)) = \sum_{(i,t)\in E} f((i,t)) - \sum_{(t,j)\in E} f((t,j))."/></p>
</div><p>This problem clearly has a linear programming formulation, which
we solve below for <code class="docutils literal"><span class="pre">s=16</span></code> and <code class="docutils literal"><span class="pre">t=10</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">maxflow</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">Problem</span><span class="p">()</span>
<span class="c">#source and sink nodes</span>
<span class="n">s</span><span class="o">=</span><span class="mi">16</span>
<span class="n">t</span><span class="o">=</span><span class="mi">10</span>

<span class="c">#convert the capacities as a picos expression</span>
<span class="n">cc</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">new_param</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>

<span class="c">#flow variable</span>
<span class="n">f</span><span class="o">=</span><span class="p">{}</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">f</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">=</span><span class="n">maxflow</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;f[{0}]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>


<span class="c">#flow value</span>
<span class="n">F</span><span class="o">=</span><span class="n">maxflow</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;F&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c">#upper bound on the flows</span>
<span class="n">maxflow</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">&lt;</span><span class="n">cc</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span> <span class="c">#list of constraints</span>
        <span class="p">[(</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span>                       <span class="c">#e is a double index (start and end node of the edges)</span>
        <span class="s">&#39;edges&#39;</span>                          <span class="c">#set the index belongs to</span>
        <span class="p">)</span>

<span class="c">#flow conservation</span>
<span class="n">maxflow</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
<span class="p">[</span>   <span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span><span class="s">&#39;p&#39;</span><span class="p">,</span><span class="s">&#39;pred(i)&#39;</span><span class="p">)</span>
<span class="o">==</span> <span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span><span class="s">&#39;j&#39;</span><span class="p">,</span><span class="s">&#39;succ(i)&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)],</span>
        <span class="s">&#39;i&#39;</span><span class="p">,</span><span class="s">&#39;nodes-(s,t)&#39;</span><span class="p">)</span>

<span class="c">#source flow at s</span>
<span class="n">maxflow</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span>
<span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">s</span><span class="p">)],</span><span class="s">&#39;p&#39;</span><span class="p">,</span><span class="s">&#39;pred(s)&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">F</span>
<span class="o">==</span> <span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">s</span><span class="p">)],</span><span class="s">&#39;j&#39;</span><span class="p">,</span><span class="s">&#39;succ(s)&#39;</span><span class="p">)</span>
<span class="p">)</span>

<span class="c">#sink flow at t</span>
<span class="n">maxflow</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span>
<span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span><span class="s">&#39;p&#39;</span><span class="p">,</span><span class="s">&#39;pred(t)&#39;</span><span class="p">)</span>
<span class="o">==</span> <span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span><span class="s">&#39;j&#39;</span><span class="p">,</span><span class="s">&#39;succ(t)&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">F</span>
<span class="p">)</span>

<span class="c">#nonnegativity of the flows</span>
<span class="n">maxflow</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span>    <span class="c">#list of constraints</span>
        <span class="p">[(</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span>                      <span class="c">#e is a double index (origin and desitnation of the edges)</span>
        <span class="s">&#39;edges&#39;</span>                         <span class="c">#set the index belongs to</span>
        <span class="p">)</span>

<span class="c">#objective</span>
<span class="n">maxflow</span><span class="o">.</span><span class="n">set_objective</span><span class="p">(</span><span class="s">&#39;max&#39;</span><span class="p">,</span><span class="n">F</span><span class="p">)</span>

<span class="c">#solve the problem</span>
<span class="k">print</span> <span class="n">maxflow</span>
<span class="n">maxflow</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;The optimal flow has value {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>---------------------
optimization problem  (LP):
61 variables, 140 affine constraints

f   : dict of 60 variables, (1, 1), continuous
F   : (1, 1), continuous

        maximize F
such that
f[e] &lt; c[e] for all e in edges
Σ_{p in pred(i)} f[(p, i)] = Σ_{j in succ(i)} f[(i, j)] for all i in nodes-(s,t)
Σ_{p in pred(s)} f[(p, 16)] + F = Σ_{j in succ(s)} f[(16, j)]
Σ_{p in pred(t)} f[(p, 10)] = Σ_{j in succ(t)} f[(10, j)] + F
f[e] &gt; 0 for all e in edges
---------------------
The optimal flow has value 15.0
</pre></div>
</div>
<p id="newversion">An equivalent and faster way to define this problem is to use the
function <a class="reference internal" href="tools.html#picos.tools.flow_Constraint" title="picos.tools.flow_Constraint"><code class="xref py py-func docutils literal"><span class="pre">flow_Constraint()</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">maxflow2</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">Problem</span><span class="p">()</span>
<span class="c"># Flow variable</span>
<span class="n">f</span><span class="o">=</span><span class="p">{}</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">f</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">=</span><span class="n">maxflow2</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;f[{0}]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># Flow value</span>
<span class="n">F</span><span class="o">=</span><span class="n">maxflow2</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;F&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># Creating a flow Constraint</span>
<span class="n">flowCons</span> <span class="o">=</span> <span class="n">pic</span><span class="o">.</span><span class="n">flow_Constraint</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">sink</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="s">&#39;capacity&#39;</span><span class="p">,</span> <span class="n">flow_value</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">graphName</span><span class="o">=</span><span class="s">&#39;G&#39;</span><span class="p">)</span>
<span class="n">maxflow2</span><span class="o">.</span><span class="n">addConstraint</span><span class="p">(</span><span class="n">flowCons</span><span class="p">)</span>

<span class="c"># Objective</span>
<span class="n">maxflow2</span><span class="o">.</span><span class="n">set_objective</span><span class="p">(</span><span class="s">&#39;max&#39;</span><span class="p">,</span><span class="n">F</span><span class="p">)</span>

<span class="c"># Solve the problem</span>
<span class="n">maxflow2</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">print</span> <span class="n">maxflow2</span>
<span class="k">print</span> <span class="s">&#39;The optimal flow has value {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>---------------------
optimization problem  (LP):
61 variables, 139 affine constraints

f       : dict of 60 variables, (1, 1), continuous
F       : (1, 1), continuous

        maximize F
such that
    Flow conservation in G from 16 to 10 with value F
---------------------
The optimal flow has value 15.0
</pre></div>
</div>
<p>Let us now draw the maximum flow:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#display the graph</span>
<span class="kn">import</span> <span class="nn">pylab</span>
<span class="n">fig</span><span class="o">=</span><span class="n">pylab</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

<span class="n">node_colors</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;w&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">N</span>
<span class="n">node_colors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="s">&#39;g&#39;</span> <span class="c">#source is green</span>
<span class="n">node_colors</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="s">&#39;b&#39;</span> <span class="c">#sink is blue</span>

<span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="c">#edges</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">edgelist</span><span class="o">=</span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">node_color</span><span class="o">=</span><span class="n">node_colors</span><span class="p">)</span>


<span class="n">labels</span><span class="o">=</span><span class="p">{</span><span class="n">e</span><span class="p">:</span><span class="s">&#39;{0}/{1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">e</span><span class="p">],</span><span class="n">c</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">}</span>
<span class="c">#flow label</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
                        <span class="n">edge_labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>

<span class="c">#hide axis</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>

<span class="n">pylab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="./pyplots/maxflow.py">Source code</a>, <a class="reference external" href="./pyplots/maxflow.png">png</a>, <a class="reference external" href="./pyplots/maxflow.hires.png">hires.png</a>, <a class="reference external" href="./pyplots/maxflow.pdf">pdf</a>)</p>
<div class="figure">
<img alt="_images/maxflow.png" src="_images/maxflow.png" />
</div>
<p>The graph shows the source in blue, the sink in green,
and the value of the flow together with the capacity on each edge.</p>
</div>
<div class="section" id="min-cut">
<h3>Min-cut<a class="headerlink" href="#min-cut" title="Permalink to this headline">¶</a></h3>
<p>Given a directed graph <img class="math" src="_images/math/225201b9f4e7b5d520f232cd2d2b27f402301764.png" alt="G(V,E)"/>,
with a capacity <img class="math" src="_images/math/6bbf77e6a4c4ee5647d9bb12100f0555505c1954.png" alt="c(e)"/> on each edge <img class="math" src="_images/math/9ff045e434b25b68e0fea4e8edf37606ca9d8a9b.png" alt="e \in E"/>,
a source node <img class="math" src="_images/math/6859317dd1b439cef34131bcd4bafee8393444e0.png" alt="s"/> and a sink node <img class="math" src="_images/math/ef9270877405055756d345facd044e4ab297f858.png" alt="t"/>, the <strong>min-cut</strong> problem is
to find a partition of the nodes in two sets <img class="math" src="_images/math/be657cdc864010de15610408fb53a384c8cd5fce.png" alt="(S,T)"/>, such that
<img class="math" src="_images/math/2af29beb16946f3fad41d9b87379c843d42af1c2.png" alt="s\in S"/>, <img class="math" src="_images/math/42fdf75a3e1060c05634640347fe398dc2a077ac.png" alt="t \in T"/>, and the total capacity of the cut,
<img class="math" src="_images/math/202fa79c8c24454ad3910271fcbd6463639e6d83.png" alt="\mathrm{capacity}(S,T)=\sum_{(i,j)\in E \cap S \times T} c((i,j)),"/> is minimized.</p>
<p>It can be seen that binary solutions <img class="math" src="_images/math/63fa61f50d1cc277b8aea22c7a82a72220f52c18.png" alt="d\in\{0,1\}^E,\ p\in\{0,1\}^V"/>
of the following linear program yield a minimum cut:</p>
<div class="math">
<p><img src="_images/math/c3b0cd83a114751b4f535d43393fdc14ef0c260c.png" alt="\begin{center}
\begin{eqnarray*}
&amp;\underset{\substack{d \in \mathbb{R}^E\\
                          p \in \mathbb{R}^V}}
             {\mbox{minimize}}
                   &amp; \sum_{e \in E} c(e) d(e)\\
&amp;\mbox{subject to} &amp; \forall (i,j) \in E,\ d((i,j)) \geq p(i)-p(j)\\
&amp;                  &amp; p(s) = 1\\
&amp;                  &amp; p(t) = 0\\
&amp;                  &amp; \forall n \in V,\ p(n) \geq 0\\
&amp;                  &amp; \forall e \in E,\ d(e) \geq 0
\end{eqnarray*}
\end{center}"/></p>
</div><p>Remarkably, this LP is the dual of the max-flow LP, and the
max-flow-min-cut theorem (also known as Ford-Fulkerson theorem <a class="reference internal" href="#graph-refs"><em>[1]</em></a>)
states that the capacity of the minimum cut is equal to the
value of the maximum flow. This means that the above LP always has
an optimal solution in which <img class="math" src="_images/math/425d86ba2f2979d75b7535c2bcf92c33ed6b285a.png" alt="d"/> is binary.
In fact, the matrix defining this LP is <em>totally unimodular</em>, from
which we know that every extreme point of the polyhedron defining the
feasible region is integral, and hence the simplex algorithm
will return a minimum cut.</p>
<p>We solve the mincut problem below, for <code class="docutils literal"><span class="pre">s=16</span></code> and <code class="docutils literal"><span class="pre">t=10</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mincut</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">Problem</span><span class="p">()</span>

<span class="c">#source and sink nodes</span>
<span class="n">s</span><span class="o">=</span><span class="mi">16</span>
<span class="n">t</span><span class="o">=</span><span class="mi">10</span>

<span class="c">#convert the capacities as a picos expression</span>
<span class="n">cc</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">new_param</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>

<span class="c">#cut variable</span>
<span class="n">d</span><span class="o">=</span><span class="p">{}</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">=</span><span class="n">mincut</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;d[{0}]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>

<span class="c">#potentials</span>
<span class="n">p</span><span class="o">=</span><span class="n">mincut</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;p&#39;</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>

<span class="c">#potential inequalities</span>
<span class="n">mincut</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span>        <span class="c">#list of constraints</span>
        <span class="p">[</span><span class="s">&#39;i&#39;</span><span class="p">,</span><span class="s">&#39;j&#39;</span><span class="p">],</span><span class="s">&#39;edges&#39;</span><span class="p">)</span>              <span class="c">#indices and set they belong to</span>

<span class="c">#one-potential at source</span>
<span class="n">mincut</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
<span class="c">#zero-potential at sink</span>
<span class="n">mincut</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>

<span class="c">#nonnegativity</span>
<span class="n">mincut</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">p</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
<span class="n">mincut</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span>    <span class="c">#list of constraints</span>
        <span class="p">[(</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span>                      <span class="c">#e is a double index (origin and desitnation of the edges)</span>
        <span class="s">&#39;edges&#39;</span>                         <span class="c">#set the index belongs to</span>
        <span class="p">)</span>

<span class="c">#objective</span>
<span class="n">mincut</span><span class="o">.</span><span class="n">set_objective</span><span class="p">(</span><span class="s">&#39;min&#39;</span><span class="p">,</span>
                <span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">cc</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span>
                        <span class="p">[(</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span><span class="s">&#39;edges&#39;</span><span class="p">)</span>
                <span class="p">)</span>

<span class="k">print</span> <span class="n">mincut</span>
<span class="n">mincut</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;The minimal cut has capacity {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">mincut</span><span class="o">.</span><span class="n">obj_value</span><span class="p">()))</span>

<span class="n">cut</span><span class="o">=</span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">]</span> <span class="c">#we round because some solvers return</span>
<span class="n">S</span>  <span class="o">=</span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">]</span> <span class="c">#0 or 1 up to the numerical precision</span>
<span class="n">T</span>  <span class="o">=</span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">]</span>

<span class="k">print</span> <span class="s">&#39;the partition of the nodes is: &#39;</span>
<span class="k">print</span> <span class="s">&#39;S: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;T: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>---------------------
optimization problem  (LP):
80 variables, 142 affine constraints

d   : dict of 60 variables, (1, 1), continuous
p   : (20, 1), continuous

        minimize Σ_{e in edges} c[e]*d[e]
such that
d[(i, j)] &gt; p[i] -p[j] for all (i,j) in edges
p[16] = 1.0
p[10] = 0
p &gt; |0|
d[e] &gt; 0 for all e in edges
---------------------
The minimal cut has capacity 15.0
the partition of the nodes is:
S: [15, 16, 17, 18]
T: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 19]
</pre></div>
</div>
<p>Note that the minimum-cut could also habe been found by using the dual variables
of the maxflow LP:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c">#capacited flow constraint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">capaflow</span><span class="o">=</span><span class="n">maxflow</span><span class="o">.</span><span class="n">get_constraint</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dualcut</span><span class="o">=</span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">capaflow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#flow conservation constraint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consflow</span><span class="o">=</span><span class="n">maxflow</span><span class="o">.</span><span class="n">get_constraint</span><span class="p">((</span><span class="mi">1</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sdual</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">+</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span>
<span class="gp">... </span>          <span class="nb">enumerate</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)])</span>
<span class="gp">... </span>          <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">consflow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tdual</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">+</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span>
<span class="gp">... </span>          <span class="nb">enumerate</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)])</span>
<span class="gp">... </span>          <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">consflow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">1e-6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cut</span> <span class="o">==</span> <span class="n">dualcut</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">set</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">Sdual</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">set</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">Tdual</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us now draw the maximum flow:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pylab</span>
<span class="n">fig</span><span class="o">=</span><span class="n">pylab</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

<span class="n">node_colors</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;w&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">N</span>
<span class="n">node_colors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="s">&#39;g&#39;</span> <span class="c">#source is green</span>
<span class="n">node_colors</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="s">&#39;b&#39;</span> <span class="c">#sink is blue</span>

<span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="c">#edges (not in the cut)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">edgelist</span><span class="o">=</span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cut</span><span class="p">],</span>
                <span class="n">node_color</span><span class="o">=</span><span class="n">node_colors</span><span class="p">)</span>

<span class="c">#edges of the cut</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">edgelist</span><span class="o">=</span><span class="n">cut</span><span class="p">,</span>
                <span class="n">edge_color</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">)</span>

<span class="c">#hide axis</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>

<span class="n">pylab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="./pyplots/mincut.py">Source code</a>, <a class="reference external" href="./pyplots/mincut.png">png</a>, <a class="reference external" href="./pyplots/mincut.hires.png">hires.png</a>, <a class="reference external" href="./pyplots/mincut.pdf">pdf</a>)</p>
<div class="figure">
<img alt="_images/mincut.png" src="_images/mincut.png" />
</div>
<p>On this graph, the source in blue, the sink in green,
and the edges defining the cut are marked in red.</p>
</div>
</div>
<div class="section" id="multicut-mip">
<h2>Multicut (MIP)<a class="headerlink" href="#multicut-mip" title="Permalink to this headline">¶</a></h2>
<p>Multicut is a generalization of the mincut problem, in which several pairs
of nodes must be disconnected. The goal is to find a cut of minimal
capacity, such that for all pair <img class="math" src="_images/math/ffd52e524ecd43d9da48d457fb939592d9ca6f4b.png" alt="(s,t) \in \mathcal{P}=\{(s_1,t_1),\ldots,(s_k,t_k))\}"/>,
there is no path from <img class="math" src="_images/math/6859317dd1b439cef34131bcd4bafee8393444e0.png" alt="s"/> to <cite>t</cite> in the graph where the edges of the cut
have been removed.</p>
<p>We can obtain a MIP formulation of the multicut problem
by doing a small modification the <em>mincut</em> LP.
The idea is to introduce a different potential for every node
which is the source of a pair in <img class="math" src="_images/math/4c101166e8245c7d7b26909dca5ef6514cfb8c8a.png" alt="\mathcal{P}"/>:</p>
<div class="math">
<p><img src="_images/math/e2a21a8aa45e49652e4e9eb9c585590c8e764987.png" alt="\forall s \in \mathcal{S}=\{s\in V: \exists t \in V\ (s,t)\in\mathcal{P}\},
p_s \in \mathbb{R}^V,"/></p>
</div><p>and to force the cut variable to be binary.</p>
<div class="math">
<p><img src="_images/math/187003a8ba4c23225622c5c9578dc61e5d90a203.png" alt="\begin{center}
\begin{eqnarray*}
&amp;\underset{\substack{y \in \{0,1\}^E\\
                     \forall s \in \mathcal{S},\ p_s \in \mathbb{R}^V}}
             {\mbox{minimize}}
                   &amp; \sum_{e \in E} c(e) y(e)\\
&amp;\mbox{subject to} &amp; \forall (i,j),s \in E\times\mathcal{S},\ y((i,j)) \geq p_s(i)-p_s(j)\\
&amp;                  &amp; \forall s \in \mathcal{S},\ p_s(s) = 1\\
&amp;                  &amp; \forall (s,t) \in \mathcal{P},\ p_s(t) = 0\\
&amp;                  &amp; \forall (s,n) \in \mathcal{S} \times V,\ p_s(n) \geq 0
\end{eqnarray*}
\end{center}"/></p>
</div><p>Unlike the mincut problem, the LP obtained by relaxing the integer constraint
<img class="math" src="_images/math/c2c5d9abcf56f1da9f278ada4a8daaad3b465f96.png" alt="y \in \{0,1\}^E"/> is not guaranteed to have an integral solution (see e.g. <a class="reference internal" href="#graph-refs"><em>[2]</em></a>).
We solve the multicut problem below, for the terminal pairs
<img class="math" src="_images/math/f46c505516d7f286a575e6c9429d2c1a5808dd70.png" alt="\mathcal{P}=\{(0,12),(1,5),(1,19),(2,11),(3,4),(3,9),(3,18),(6,15),(10,14)\}"/>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">multicut</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">Problem</span><span class="p">()</span>

<span class="c">#pairs to be separated</span>
<span class="n">pairs</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">12</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">19</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">11</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">18</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">15</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">14</span><span class="p">)]</span>

<span class="c">#source and sink nodes</span>
<span class="n">s</span><span class="o">=</span><span class="mi">16</span>
<span class="n">t</span><span class="o">=</span><span class="mi">10</span>

<span class="c">#convert the capacities as a picos expression</span>
<span class="n">cc</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">new_param</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>

<span class="c">#list of sources</span>
<span class="n">sources</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">])</span>


<span class="c">#cut variable</span>
<span class="n">y</span><span class="o">=</span><span class="p">{}</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">y</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">=</span><span class="n">multicut</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;y[{0}]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="n">vtype</span><span class="o">=</span><span class="s">&#39;binary&#39;</span><span class="p">)</span>

<span class="c">#potentials (one for each source)</span>
<span class="n">p</span><span class="o">=</span><span class="p">{}</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
        <span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="n">multicut</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;p[{0}]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">),</span><span class="n">N</span><span class="p">)</span>

<span class="c">#potential inequalities</span>
<span class="n">multicut</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span>        <span class="c">#list of constraints</span>
        <span class="p">[</span><span class="s">&#39;i&#39;</span><span class="p">,</span><span class="s">&#39;j&#39;</span><span class="p">,</span><span class="s">&#39;s&#39;</span><span class="p">],</span><span class="s">&#39;edges x sources&#39;</span><span class="p">)</span><span class="c">#indices and set they belong to</span>

<span class="c">#one-potentials at source</span>
<span class="n">multicut</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">s</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">],</span>
        <span class="s">&#39;s&#39;</span><span class="p">,</span><span class="s">&#39;sources&#39;</span><span class="p">)</span>

<span class="c">#zero-potentials at sink</span>
<span class="n">multicut</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">],</span>
        <span class="p">[</span><span class="s">&#39;s&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">],</span><span class="s">&#39;pairs&#39;</span><span class="p">)</span>

<span class="c">#nonnegativity</span>
<span class="n">multicut</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">],</span>
        <span class="s">&#39;s&#39;</span><span class="p">,</span><span class="s">&#39;sources&#39;</span><span class="p">)</span>

<span class="c">#objective</span>
<span class="n">multicut</span><span class="o">.</span><span class="n">set_objective</span><span class="p">(</span><span class="s">&#39;min&#39;</span><span class="p">,</span>
                <span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">cc</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span>
                        <span class="p">[(</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span><span class="s">&#39;edges&#39;</span><span class="p">)</span>
                <span class="p">)</span>

<span class="k">print</span> <span class="n">multicut</span>
<span class="n">multicut</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;The minimal multicut has capacity {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">multicut</span><span class="o">.</span><span class="n">obj_value</span><span class="p">())</span>

<span class="n">cut</span><span class="o">=</span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>

<span class="k">print</span> <span class="s">&#39;The edges forming the cut are: &#39;</span>
<span class="k">print</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cut</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>---------------------
optimization problem  (MIP):
180 variables, 495 affine constraints

y   : dict of 60 variables, (1, 1), binary
p   : dict of 6 variables, (20, 1), continuous

        minimize Σ_{e in edges} c[e]*y[e]
such that
y[(i, j)] &gt; p[s][i] -p[s][j] for all (i,j,s) in edges x sources
p[s][s] = 1.0 for all s in sources
p[s][t] = 0 for all (s,t) in pairs
p[s] &gt; |0| for all s in sources
---------------------
The minimal multicut has capacity 49.0
The edges forming the cut are:
[(1, 0), (1, 4), (2, 8),
 (2, 16), (3, 4), (5, 11),
 (7, 8), (9, 8), (10, 11),
 (13, 12), (13, 14),
 (13, 16), (17, 16)]
</pre></div>
</div>
<p>Let us now draw the multicut:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pylab</span>

<span class="n">fig</span><span class="o">=</span><span class="n">pylab</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

<span class="c">#pairs of dark and light colors</span>
<span class="n">colors</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;Yellow&#39;</span><span class="p">,</span><span class="s">&#39;#FFFFE0&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;#888888&#39;</span><span class="p">,</span><span class="s">&#39;#DDDDDD&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;Dodgerblue&#39;</span><span class="p">,</span><span class="s">&#39;Aqua&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;DarkGreen&#39;</span><span class="p">,</span><span class="s">&#39;GreenYellow&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;DarkViolet&#39;</span><span class="p">,</span><span class="s">&#39;Violet&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;SaddleBrown&#39;</span><span class="p">,</span><span class="s">&#39;Peru&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;Red&#39;</span><span class="p">,</span><span class="s">&#39;Tomato&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;DarkGoldenRod&#39;</span><span class="p">,</span><span class="s">&#39;Gold&#39;</span><span class="p">),</span>
        <span class="p">]</span>

<span class="n">node_colors</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;w&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">N</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sources</span><span class="p">):</span>
        <span class="n">node_colors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="p">(</span><span class="n">s0</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="n">s0</span><span class="o">==</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">node_colors</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

<span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">edgelist</span><span class="o">=</span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cut</span><span class="p">],</span>
                <span class="n">node_color</span><span class="o">=</span><span class="n">node_colors</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">edgelist</span><span class="o">=</span><span class="n">cut</span><span class="p">,</span>
                <span class="n">edge_color</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">)</span>

<span class="c">#hide axis</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>

<span class="n">pylab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="./pyplots/multicut.py">Source code</a>, <a class="reference external" href="./pyplots/multicut.png">png</a>, <a class="reference external" href="./pyplots/multicut.hires.png">hires.png</a>, <a class="reference external" href="./pyplots/multicut.pdf">pdf</a>)</p>
<div class="figure">
<img alt="_images/multicut.png" src="_images/multicut.png" />
</div>
<p>On this graph, the pairs of terminal nodes are denoted by
dark and light colors of the same shade (e.g. dark vs. light green
for the pairs (3,4),(3,9), and (3,18)), and the edges defining the
cut are marked in red.</p>
</div>
<div class="section" id="maxcut-relaxation-sdp">
<h2>Maxcut relaxation (SDP)<a class="headerlink" href="#maxcut-relaxation-sdp" title="Permalink to this headline">¶</a></h2>
<p>The goal of the <strong>maxcut</strong> problem is to find
a partition (S,T) of the nodes of an <em>undirected</em> graph G(V,E),
such that the capacity of the cut,
<img class="math" src="_images/math/535ceb120ef42e5f6d09fcbcee4c2476673d0d5b.png" alt="\mathrm{capacity}(S,T)=\sum_{\{i,j\} \in E \cap (S \Delta T)} c((i,j)),"/>
is maximized.</p>
<p>Goemans and Williamson have designed a famous 0.878-approximation
algorithm <a class="reference internal" href="#graph-refs"><em>[3]</em></a> for this NP-hard problem based on semidefinite programming.
The idea is to introduce a variable <img class="math" src="_images/math/18c83207267fed9465967a612c7559ec570ff82c.png" alt="x \in \{-1,1\}^V"/> where
<img class="math" src="_images/math/93c6ee3d61496db2bddbed7f37473837fc1363e6.png" alt="x(n)"/> takes the value +1 or -1 depending on wheter <img class="math" src="_images/math/0ff45a96347e3b822efa4dd38eda27429065c1fc.png" alt="n \in S"/>
or <img class="math" src="_images/math/dff81fcb26195a828dd2976ed434f845f6260426.png" alt="n \in T"/>. Then, it can be seen that the value of the cut
is equal to <img class="math" src="_images/math/436777f5927467cc9fd8d8f9a8344245e5403ac8.png" alt="\frac{1}{4} x^T L x"/>, where <img class="math" src="_images/math/0a5711c7a37994043b2bc3bb374adca232491762.png" alt="L"/> is the Laplacian
of the graph. If we define the matrix <img class="math" src="_images/math/e5aae8e5e5b24b1334df2730c5063e832ddb76c2.png" alt="X=xx^T"/>, which is positive
semidefinite of rank 1, we obtain an SDP by relaxing the
rank-one constraint on <img class="math" src="_images/math/f026aecf11ec7f6141ab863f260d395f94b10f51.png" alt="X"/> :</p>
<div class="math">
<p><img src="_images/math/19c11640eaf97dfb89a3b4c2416a48fde57a4f70.png" alt="\begin{center}
\begin{eqnarray*}
&amp;\underset{X \in \mathbb{S}_{|V|}}
             {\mbox{maximize}}
                   &amp; \frac{1}{4} \langle L, X \rangle \\
&amp;\mbox{subject to} &amp; \mbox{diag}(X) = \mathbf{1}\\
&amp;                  &amp; X \succeq 0
\end{eqnarray*}
\end{center}"/></p>
</div><p>Then, Goemans and Williamson have shown that if we project the solution <img class="math" src="_images/math/f026aecf11ec7f6141ab863f260d395f94b10f51.png" alt="X"/>
onto a random hyperplan, we obtain a cut whose expected capacity is at least
0.878 times the optimum. Below is a simple implementation of their algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#make G undirected</span>
<span class="n">G</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="c">#allocate weights to the edges</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;weight&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>


<span class="n">maxcut</span> <span class="o">=</span> <span class="n">pic</span><span class="o">.</span><span class="n">Problem</span><span class="p">()</span>
<span class="n">X</span><span class="o">=</span><span class="n">maxcut</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">,(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="s">&#39;symmetric&#39;</span><span class="p">)</span>

<span class="c">#Laplacian of the graph</span>
<span class="n">LL</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mf">4.</span><span class="o">*</span><span class="n">nx</span><span class="o">.</span><span class="n">laplacian_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
<span class="n">L</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">new_param</span><span class="p">(</span><span class="s">&#39;L&#39;</span><span class="p">,</span><span class="n">LL</span><span class="p">)</span>

<span class="c">#ones on the diagonal</span>
<span class="n">maxcut</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">pic</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">diag_vect</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
<span class="c">#X positive semidefinite</span>
<span class="n">maxcut</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">X</span><span class="o">&gt;&gt;</span><span class="mi">0</span><span class="p">)</span>

<span class="c">#objective</span>
<span class="n">maxcut</span><span class="o">.</span><span class="n">set_objective</span><span class="p">(</span><span class="s">&#39;max&#39;</span><span class="p">,</span><span class="n">L</span><span class="o">|</span><span class="n">X</span><span class="p">)</span>

<span class="k">print</span> <span class="n">maxcut</span>
<span class="n">maxcut</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;bound from the SDP relaxation: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">maxcut</span><span class="o">.</span><span class="n">obj_value</span><span class="p">())</span>

<span class="c">#---------------------------#</span>
<span class="c">#RANDOM PROJECTION ALGORITHM#</span>
<span class="c">#---------------------------#</span>

<span class="c">#Cholesky factorization</span>
<span class="n">V</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">value</span>

<span class="n">cvxopt</span><span class="o">.</span><span class="n">lapack</span><span class="o">.</span><span class="n">potrf</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
                <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>

<span class="c">#random projection algorithm</span>
<span class="c">#Repeat 100 times or until we are within a factor .878 of the SDP optimal value</span>
<span class="n">count</span><span class="o">=</span><span class="mi">0</span>
<span class="n">obj_sdp</span><span class="o">=</span><span class="n">maxcut</span><span class="o">.</span><span class="n">obj_value</span><span class="p">()</span>
<span class="n">obj</span><span class="o">=</span><span class="mi">0</span>
<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span><span class="mi">100</span> <span class="ow">or</span> <span class="n">obj</span><span class="o">&lt;.</span><span class="mi">878</span><span class="o">*</span><span class="n">obj_sdp</span><span class="p">):</span>
        <span class="n">r</span><span class="o">=</span><span class="n">cvx</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span><span class="o">=</span><span class="n">cvx</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="n">r</span><span class="p">))</span>
        <span class="n">o</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">&gt;</span><span class="n">obj</span><span class="p">:</span>
                <span class="n">x_cut</span><span class="o">=</span><span class="n">x</span>
                <span class="n">obj</span><span class="o">=</span><span class="n">o</span>
        <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>

<span class="k">print</span> <span class="s">&#39;value of the cut: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="n">S1</span><span class="o">=</span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span>
<span class="n">S2</span><span class="o">=</span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
<span class="n">cut</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span>

<span class="c">#we comment this because the output in unpredicatable for doctest:</span>
<span class="c">#print &#39;partition of the nodes:&#39;</span>
<span class="c">#print &#39;S1: {0}&#39;.format(S1)</span>
<span class="c">#print &#39;S2: {0}&#39;.format(S2)</span>
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>---------------------
optimization problem  (SDP):
210 variables, 20 affine constraints, 210 vars in 1 SD cones

X   : (20, 20), symmetric

        maximize 〈 L | X 〉
such that
diag(X) = |1|
X ≽ |0|
---------------------
bound from the SDP relaxation: 478.2074...
value of the cut: 471.0
</pre></div>
</div>
<p>Let us now draw this cut:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#display the cut</span>
<span class="kn">import</span> <span class="nn">pylab</span>

<span class="n">fig</span><span class="o">=</span><span class="n">pylab</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

<span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="n">node_colors</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;g&#39;</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">S1</span> <span class="k">else</span> <span class="s">&#39;b&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">edgelist</span><span class="o">=</span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cut</span><span class="p">],</span>
                <span class="n">node_color</span><span class="o">=</span><span class="n">node_colors</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">edgelist</span><span class="o">=</span><span class="n">cut</span><span class="p">,</span>
                <span class="n">edge_color</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">)</span>

<span class="c">#hide axis</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>

<span class="n">pylab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="./pyplots/maxcut.py">Source code</a>, <a class="reference external" href="./pyplots/maxcut.png">png</a>, <a class="reference external" href="./pyplots/maxcut.hires.png">hires.png</a>, <a class="reference external" href="./pyplots/maxcut.pdf">pdf</a>)</p>
<div class="figure">
<img alt="_images/maxcut.png" src="_images/maxcut.png" />
</div>
<p>On this graph, the red edges are those defining the cut, and the nodes
are blue or green depending on the partition they belong to.</p>
</div>
<div class="section" id="references">
<span id="graph-refs"></span><h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ol class="arabic simple">
<li>&#8220;Maximal Flow through a Network&#8221;, LR Ford Jr and DR Fulkerson,
<em>Canadian journal of mathematics</em>, 1956.</li>
<li>&#8220;Analysis of LP relaxations for multiway and multicut problems&#8221;,
D.Bertsimas, C.P. Teo and R. Vohra,
<em>Networks</em>, 34(2), p. <em>102-114</em>, 1999.</li>
<li>&#8220;Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming&#8221;,
M.X. Goemans and D.P. Williamson,
<em>Journal of the ACM</em>, 42(6), p. <em>1115-1145</em>, 1995.</li>
</ol>
</div></blockquote>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="complex.html" class="btn btn-neutral float-right" title="Complex Semidefinite Programming">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="optdes.html" class="btn btn-neutral" title="Examples from Optimal Experimental Design"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2012, Guillaume Sagnol.
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>